# 计算机网络（自顶向下方法）课程笔记

课程地址：[【中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程】](https://www.bilibili.com/video/BV1JV411t7ow)

## 网络概述

### 因特网概述

从具体构成角度

- 数以亿计的、互联的计算设备
- - 主机 == 端系统
  - 主机上可运行网络应用程序
- 通信链路
- - 光线、同轴电缆、无线电、卫星
- 分组交换设备
- - 路由器和交换机，用于转发分组（packets）
- 节点
- - 主机及主机上运行的应用程序
  - 路由器、交换机等网络交换设备
- 边（通信链路）
- - 接入网链路（Access）：主机连接到互联网的链路
  - 主干链路（Backbone）：路由器之间的额链路
- 协议
- 协议就是规范、标准，控制发送和接收消息，如TCP、IP、HTTP、FTP
- 对等层实体“沟通”的标准：如交换的报文**格式和次序**，以及报文传输和接收或其他事件方面采取的**动作**

从服务角度

- 使用通信设施进行通信的分布式应用，如Web、VoIP、Email、电子商务、社交网络、分布式游戏
- 通信基础设施为APP提供的编程接口（通信服务）
  - 将发送和接收数据的APP与互联网连接起来
  - 为APP提供服务：无连接不可靠服务或面向连接的可靠服务

### 网络边缘

网络边缘是主机以及运行在主机上的应用程序。

网络边缘通信有两种模式：

- C/S模式：客户端向服务器请求并接收服务（客户端主动请求资源，服务器被动响应），如Web浏览器和服务器、Email客户端和服务器
- P2P模式：没有专门的服务器，或者说每个主机同时是客户端和服务器，如Gnutella、KaZaA、Emule

TCP协议——传输控制协议

- 可靠地、保序地传输数据，会确认和重传
- 流量控制，发送方不会淹没接收方
- 拥塞控制，当网络拥塞时，发送方降低发送速率

UDP协议——用户数据报协议

- 无连接
- 不可靠地、不保序地数据传输
- 无流量控制
- 无拥塞控制

使用TCP的应用：HTTP（Web）、FTP、Telnet（远程登录）、SMTP（邮件）

使用UDP的应用：流媒体、远程会议、DNS、Internet电话

### 网络核心

网络核心是路由器构成的网状网络，数据有两种传输方式：

- 电路交换（Circuit Switch）：为每个呼叫预留一条专有电路，如电话网

  - 独享资源，每个呼叫一旦建立起来就能保证性能

  - 如果呼叫没有数据发送，被分配的资源就会浪费

  - 电路交互不适合计算机之间的通信

    - 连接建立时间长
    - 计算机之间的通信有突发性，使用电路交换则浪费的片较多
    - 可靠性不高

  - 网络资源被分成**片**，有频分（Frequency Division）、时分（Time Division）、波分，为呼叫分配片，如果某呼叫没有数据，则其资源片处于空闲状态（不共享）

    ![image-20250228182937980](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228182937980.png)

- 分组交换：以分组为单位进行存储、转发

  - 网络带宽资源不在分为片，传输时使用**全部带宽**，采用**统计多路复用**

  - 将要传输的数据分成一个个单位（分组）

  - 将分组从一个路由器传到相邻路由器（Hop）一段段最终从源端传到目标端

  - 在转发之前，节点必须受到**整个分组**

  - 排队延迟和丢失：如果分组到达速率高于链路传输速率，分组会排队等待传输；如果路由器缓存用完了，分组会被抛弃

    ![image-20250228183648092](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228183648092.png)

网络核心的关键功能

- 路由：用路由算法决定分组采用的从源到目标的路径

  ![image-20250228183853493](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228183853493.png)

- 转发：将分组从路由器的输入链路转移到输出链路

数据报（Datagram）的工作原理

- 通信之前无需建立起连接，有数据就传输
- 每一个分组都独立路由（由于路径不一样，可能会失序）
- 路由器根据分组的目标地址进行路由

虚电路（Virtual Circuit）的工作原理

在数据传输前，发送方和接收方之间通过信令协议建立一条逻辑连接。网络节点根据路由算法选择路径，并预留资源（如带宽、缓冲区）。建立完成后，网络会分配一个虚电路标识符（VCI），用于标识该连接。

### 接入网

怎样将端系统和边缘路由器连接？

- 住宅接入网络

  - Modem：将上网数据**调制**加载到音频信号上，在电话线上传输，端系统将数据解调出来；拨号调制解调器以56kbps的速率直接接入路由器，不能同时上网和打电话
    - 调幅
    - 调频
    - 调相位
    - 综合调制
  - 数字用户线路（DSL）：一种通过普通电话线提供高速互联网接入的技术
    - 它利用电话线中的高频段传输数据，不影响低频段的语音通信，因此可以同时上网和打电话
    - DSL线路上的数据被传到互联网（4khz以上），语音被传到电话网（4khz以下）
    - 分给数据的线路分为上行和下行
  - 线缆网络：
    - 有线电视信号线缆双向改造，在不同频段传输不同信道的数据，数字电视和上网数据（上下行）
    - HFC：线缆和光纤将家庭用户接入到ISP路由器，各用户贡献到线缆头端的接入网络

  ![image-20250228185834124](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228185834124.png)

- 单位接入网络

  - 端系统直接接到以太网交换机上

  ![image-20250228190048390](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228190048390.png)

- 无线网络

  - WLAN：建筑物内部
  - 广域无线接入：由电信运营商提供

### 物理媒体

导引性媒体：信号沿着固体媒介被导引，如同轴电缆、光纤、双绞纤

- 同轴电缆：两根同轴地铜导线、双向
  - 基带电缆：电缆上有单个信道
  - 宽带电缆：电缆上有多个信道
- 光纤和光缆：光脉冲，一个脉冲代表1bit，高速、低误码率、安全

非导引性媒体：信号自由传播，如无线电

- 开放空间传输电磁波无需物理线缆
- 传播环境效应：反射、吸收、干扰
- 类型：地面微波、LAN（WiFi）、wide-area（蜂窝）、卫星

### 因特网结构和ISP

ISP（Internet Service Provider）即互联网服务提供商，是向用户提供互联网接入和服务的公司或组织。

主要服务包括：

1. 互联网接入：通过宽带、光纤、DSL、无线等方式连接互联网。
2. 电子邮件和网页托管：提供电子邮箱和网站托管服务。
3. 虚拟专用网（VPN）：提供安全的远程访问服务。
4. 云服务：提供数据存储、备份等云服务。
5. 技术支持：提供网络设置、故障排除等帮助。

类型

1. 拨号ISP：通过电话线接入，速度较慢。
2. 宽带ISP：提供高速连接，如DSL、光纤等。
3. 无线ISP：通过无线技术提供接入。
4. 卫星ISP：通过卫星为偏远地区提供连接。

端系统通过**接入ISP**链接到互联网，接入ISP是互相连接的

每个ISP都连接到全局ISP（global ISP），接入ISP和全局ISP往往有经济合约

- 对等连接：

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301015102123.png)

- IXP（Internet Exchange Point）即互联网交换点，是不同网络服务提供商（ISP）和内容分发网络（CDN）之间交换流量的物理基础设施：

![image-20250301015153250](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301015153250.png)

业务细分为全球接入和区域接入，区域网络出现，用于将接入ISP连接到全局ISP

![image-20250301015316289](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301015316289.png)

ICP（Internet Content Provider）即互联网内容提供商，是指在互联网上提供各类信息、服务或应用的公司或组织。它们通过网站、应用程序等平台向用户提供内容。

主要类型

1. 新闻门户：如新浪、搜狐，提供新闻资讯。
2. 视频平台：如优酷、爱奇艺，提供视频内容。
3. 社交网络：如微信、微博，提供社交服务。
4. 电子商务：如淘宝、京东，提供在线购物。
5. 搜索引擎：如百度、Google，提供信息检索。

ICP为了减少运营支出、给用户提供更好的服务，会在全球各地部署数据中心机房，用专线连接在一起，数据中心机房往往靠近核心ISP的路由设备

![image-20250301020120329](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301020120329.png)

### 分组延时、丢失和吞吐量

在路由缓冲区有分组队列，分组等待排到队头被传输

四种延时：

- 节点处理延时：检查bit级差错，检查分组头部并决定将分组导向何处
- 排队延时：排队延时：在输出链路上等待传输的时间，依赖于路由器的拥塞程度
- 传输延时：L/R，其中R是链路带宽（bps），L是分组长度（bits）
- 传播延时：d/s，d是物理链路的长度，s是媒介传输速度

流量强度：I=La/R，流量强度不能超过1

分组丢失：由于链路的队列缓冲区容量有限，当分组到达一个满的队列时，该分组会丢失。

丢失的分组可能会被前一个节点或端系统重传，或根本不重传。
吞吐量：在源端和目标端之间的传输速率（数据量/单位时间）

- 瞬间吞吐量
- 平均吞吐量

![image-20250301125223409](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301125223409.png)

瓶颈链路：端到端的路径上，限制端到端吞吐的链路

### 协议层次和服务模型

### 互联网历史

## 应用层

### Web和HTTP

### FTP

### EMail

### DNS

### P2P

### CDN

CDN（Content Distribution Networks）

背景：服务器如何通过网络向上百万用户同时提供流化视频内容？

选择1：单个的、大的超级服务中心——Mega Server

- 服务器到客户端路径上Hop多，瓶颈链路带宽小
- 二八定律（同一个视频的多个拷贝）
- 单点故障、性能瓶颈
- 周边网络拥塞

选择2：通过CDN，全网部署缓存节点，就近为用户提供内容加速服务

- ICP购买CDN运营商的服务，将内容提前部署于缓存节点，用户通过域名**重定向**找到最近的缓存节点（网络拥塞，可能寻找其他节点）；部署有两种策略：

  - enter deep：将CDN服务器深入接入网，数量多、离用户近；

  - bring home：部署在少数（10个左右）关键位置（安装于ISP POP附近）；采用租用线路将服务器簇链接起来

### Socket

套接字：应用进程与端到端传输协议（TCP或UDP）之间的**门户**

TCP Socket

TCP/IP：应用进程使用Socket API访问传输服务；位于层间接口的服务访问点（SAP）

```
struct socketaddr_in {
	short sin_family; // 地址簇
	u_short sin_port; // 端口
	struct in_addr sin_addr; // IP地址
	char sin_zero[8]; // 对齐 
}

// 作为调用域名解析函数时的参数
struct hostend {
	char *h_name; // 主机域名
	char **h_aliases; // 域名别名
	int h_addrtype; // 地址类型
	int h_length; // 地址长度
	char **h_addr_list; // IP地址
}
```

服务端：

绑定ip地址和端口号

welcome socket守候在某个端口，等待客户端连接

客户端连接之后返回一个connectionSocket作为会话标志

// TODO C语言代码



客户端：
隐式绑定ip地址和端口号

指定服务器的ip地址和端口号进行连接

连接之后返回一个connectionSocket作为会话标志

// TODO C语言代码



UDP Socket

客户端和服务端之间没有建立连接、没有握手

发送端在每一个报文中指定接受端的ip地址和端口号

接收端必须从收到的分组中提取出发送端的IP地址和端口号

// TODO 服务端C语言代码

// TODO 客户端C语言代码

## 传输层

### 传输层服务

为运行在不同主机上的应用进程提供逻辑通信

传输协议运行在端系统，可选择不同的协议（如TCP和UDP）

- 发送方将应用层的报文分成报文段，传递给网络层
- 接受方将报文段重组成报文，传递给应用层

传输层依赖网络层的服务，并对网络层的部分服务进行增强（数据丢失、乱序、加密可以增强，延时和带块不可增强）

可靠的保序的传输（字节流）：TCP

- 多路复用、解复用
- 拥塞控制
- 流量控制
- 建立连接

不可靠不保序的传输（数据报）：UDP

- 多路复用、解复用

### 多路复用和解服用

TCP的复用和解复用

复用：

应用层往下交TCP Socket和消息本身，TCP Socket包含源IP、源Port、目标IP、目标Port；

TCP层把源Port和目标Port和消息一起封装成TCP的段（Segment），和源IP、目标IP一起往下交

IP层拿到TCP的段（Segment）和源IP、目标IP后，封装成IP的段，传给网络层



解复用：

IP层把数据部分（即TCP的段）和源IP、目标IP一起交给TCP层

TCP层根据头部的**源Port、目标Port**和IP层传来的源IP、目标IP，从表格中查询到对应的Socket和PID

根据PID知道是哪个应用进程，把消息传给应用进程



UDP的复用和解复用

复用：

应用层往下交1.UDP Socket（TCP Socket包含源IP、源Port）、2.消息本身和3.目标IP和目标Port；

UDP层把**源Port、目标Port**和消息一起封装成UDP段（报文），和源IP、目标IP一起往下交

IP层拿到UDP的报文和源IP、目标IP后，封装成IP的段传给网络层



解复用：

IP层把数据部分（即UDP的报文）和源IP、目标IP一起交给UDP层

UDP层根据传上来的目标IP和报文中的目标Port，从表格中查询到对应的Socket和PID

根据PID知道是哪个应用进程，把消息传给应用进程



UDP可以一对多，TCP只能一对一

![image-20250228120236034](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228120236034.png)

![image-20250228120209794](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228120209794.png)

Socket的作用：使得穿过层间的信息最少

复用（在发送方主机多路复用）：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号，给报文段加上头部信息加以封装（头部信息用于以后解复用）

解复用（接收方主机多路解复用）：根据报文段头部信息的IP地址和端口号将接收到的报文段发给正确的套接字和对应的应用进程

### 无连接传输

UDP数据报的格式：

- 头部：由四个字段组成，每个字段占2字节，总长度为8字节
  1. **源端口（Source Port）**：
     - 2字节，标识发送方的端口号。
     - 可选，若不使用则置为0。
  2. **目的端口（Destination Port）**：
     - 2字节，标识接收方的端口号。
  3. **长度（Length）**：
     - 2字节，表示整个UDP报文的长度，包括头部和数据部分。
     - 最小值为8（仅头部），最大值为65535。
  4. **校验和（Checksum）**：
     - 2字节，用于检测数据在传输中的错误。
     - 在IPv4中可选，若未计算则置为0；在IPv6中强制使用。
- 应用程序数据（载荷）

![image-20250228121110656](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228121110656.png)

UDP存在的必要性：

简单，发送端和接收端没有连接状态

报文头部小

可以尽可能快的发送



校验和如何工作：

发送方计算校验和

- 数据分块：将数据划分为16位（2字节）的块。
- 求和：对这些块进行二进制求和（进位回滚）。
- 取反码：将求和结果取反码，得到校验和（EDC）。
- 插入校验和：将计算出的校验和插入到报文的校验和字段中。

接收方验证校验和

- 数据分块：同样将数据划分为16位块，包括校验和字段。
- 求和：对这些块（包含校验和）进行二进制求和（进位回滚）+取反码。
- 检查结果：若结果不为0，数据一定有误，报文被丢弃；结果为0，数据基本正确，但有可能存在残存差错（Residual Error）

伪头部（UDP/TCP）

- 增强校验：UDP和TCP在校验和计算中加入伪头部，包含源IP、目的IP、协议类型和长度等信息，确保这些字段未被篡改。

### 可靠数据传输

可靠数据传输（RDT）：信道的不可靠特点决定了可靠数据传输协议的复杂性

![image-20250228140358743](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228140358743.png)

使用有限状态机（FSM）描述发送方和接收方

RDT1.0：在可靠信道上的可靠数据传输；什么都不敢，封装、解封装

下层的信道是完全可靠的

- 没有比特出错
- 没有分组丢失

发送方和接收方的有限状态机

- 发送方将数据发送到下层信道
- 接收方从下层信道接收数据

![image-20250228141523559](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228141523559.png)

RDT2.0：停止等待协议（Stop-and-Wait）

具有比特差错的信道->下层信道可能会出错，将分组中的比特翻转

1. 用校验和来检测比特差错

问题：怎样从差错中恢复？

- 确认（ACK）：接收方显式地告诉发送方分组已被正确接收
- 否定确认（NAK）：接收方显式地告诉发送方分组发生了差错，发送方收到NAK后重新发送分组

发送方发完之后要留个副本，用于检错重传

采用差错控制编码（EDC）判断分组是否有差错

![image-20250228142248602](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228142248602.png)

RDT2.1：

发送方处理出错的ACK/NAK（ACK或NAK corrupt了）

- 给packet编号，如果收到的不是ACK或NAK，就重发上次packet

![image-20250228143452765](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228143452765.png)

接收方要给ACK和NAK也加EDC（差错控制编码）

等待n+1号packet时（说明之前已经收到过n号packet）：

- 再次收到没出错的n号packet，把收到的n号packet丢弃，并发送一个ACK
- 再次收到出错的packet，就发送一个NAK
- 收到没出错的n+1号packet，解封装、向上层传递数据，然后发送一个ACK，进入等待n+2号packet的状态

![image-20250228144918614](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228144918614.png)

细节：

发送方：

- 在分组中加入序列号，如果一次只发送一个未经确认的分组，用两个序列号（0和1）就够了
- 必须检测ACK/NAK是否出错（给ACK/NAK加EDC）
- 状态数变成了原来的两倍，因为需要记当前分组的序列号是0还是1

接收方：

- 必须检测收到的分组是否是重复的，状态会指示希望收到的分组需要是0还是1
- 接收方并不知道发送方是否正确收到了ACK/NAK

![image-20250228145326782](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228145326782.png)

RDT2.2：没有NAK的协议（NAK Free）

功能同RDT2.1，但只使用ACK（且ACK需要编号）

- 接收方对**最后**正确接收的分组发ACK，以代替NAK；接收方发的ACK必须显示地包含被正确接收的分组的序号
  - 比如接收方收1号packet出错，不是发NAK1，而是发ACK0，表示1号packet接收出错，这样就不需要NAK了

- 当发送方重复收到ACK（如再次收到ACK0）时，发送方重传当前分组

![image-20250228150730206](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228150730206.png)

![image-20250228150329573](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228150329573.png)

![image-20250228150347614](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228150347614.png)

- 为后面一次发送多个数据单位（pipeline协议）做准备
  - 一次能发送多个数据包
  - 使用对前一个数据单位的ACK，代替本数据单位的NAK
  - 优点是确认信息减少一半，协议处理简单

RDT3.0：超时重传机制

原因：下层信道可能会丢失分组（ACK丢失或packet丢失）

- 造成死锁
- 目前的机制（检验和、序列号、ACK、重传）还不够处理这种状况

解决方法：

- 发送端超时重传，每次发送分组后**启动**计时器，如果超过Timeout，就重传分组并**重置计时器**
- 收到正确的包之后关闭计时器，在计时器关闭期间不理会收到的包
- 数据链路层的Timeout时间是确定的，传输层的Timeout时间是适应性的（动态计算）

发送方：

细节：和RDT2.2不同，收到上一个packet的ACK之后，并不会立即重传，而是“按兵不动”，等待超时，因为超时了也会重传

![image-20250228152150044](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228152150044.png)

超时计时器需要设置合理的Timeout，Timeout设置太短，也能正常工作，但是效率较低，会重复发送PKT和ACK

![image-20250228152931295](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228152931295.png)

RDT3.0的性能

RDT3.0可以工作，但信道容量较大的情况下，一次发一个PDU不能够充分利用链路的传输能力，瓶颈在于网络协议限制了物理资源的利用

流水线协议：允许发送方在**未得到对方确认**的情况下一次发送多个分组

- 必须增加序号的范围，用多个bit表示分组序号
- 发送方/接收方要有缓冲区
  - 发送方缓冲：未得到确认，可能需要重传分组
  - 接收方缓冲：1.上层用户取用数据的速率≠接收到的数据速率；2.接收到的数据可能乱序，需要排序后交付

![image-20250228154208792](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228154208792.png)一次发n个分组使得链路利用率提高到n倍，但U达到100%时，无法再通过增加n来提高利用率；瓶颈转移到了链路带宽

滑动窗口（Slide Window）协议

- 发送缓冲区
  - 形式：内存中的一个区域，落入缓冲区的分组可以发送
  - 功能：用于存放已经发送但是没有得到确认的分组
  - 必要性：需要重发时使用
- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组？
  - 停止等待协议：缓冲区大小==1
  - 流水线协议：缓冲区大小＞1，需要是合理的值，但是不能很大，链路利用率不能超过100%
- 发送缓冲区中的分组：
  - 未发送的：落入发送缓冲区的分组可以连续发送出去
  - 已经发送出去的、等待对方确认的分组：只有得到确认后才可删除

发送窗口：发送缓冲区的一个子集（长度≤发送缓冲区长度），表示那些已发送但未经确认的分组的序号构成的空间

- 一开始没有发送任何一个分组
  - 后沿==前沿
  - 每发送一个分组，前沿前移一个单位
- 收到已发送分组的确认
  - 发送缓冲区整体向前移动
  - 发送窗口后沿向前移动

![image-20250228155958506](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228155958506.png)

![image-20250228160517999](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228160517999.png)

![image-20250228160633874](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228160633874.png)

过程：

![image-20250228160800059](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228160800059.png)

接收窗口：**等同于**接受缓冲区

- 用于控制哪些分组可以接受

  - 只有收到的分组序号落入接收窗口内才允许接收
  - 若序号在接收窗口外，则丢弃

- 接收窗口的滑动和发送确认

  - 滑动：
    - 最低序号的分组到来，接收窗口滑动
    - 非最低序号的分组到来（乱序），缓存但不交付，因此不滑动
  - 发送确认：
    - 接收窗口大小==1时，发送连续收到的最大分组的确认（累计确认）
    - 接收窗口大小＞1时，收到哪个分组就发送哪个分组的确认（非累计确认）

- 接收窗口大小

  - 接收窗口大小==1 -> 回退N步协议（Go Back N），**只能顺序接收**

    ![image-20250228161618015](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228161618015.png)

  - 接受窗口大小 > 1 -> 选择重传协议（Selective Repeat），**可以乱序**接收，但**提交给上层的分组要按序**

    ![](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228163039478.png)

两种通用的流水线协议：回退N步（GBN）和选择重传（SR）

// 比较用表格表示

- 相同之处：
  - 发送窗口＞1
  - 一次可发多个未经确认的分组
- 不同之处：GBN中发送方每次重发会发送缓冲区中的所有分组，SR中发送方每次重发只会缓冲区中未收到确认的分组
  - GBN接收窗口大小==1；接收端只能顺序接受；发送端一旦收到ACKn，就会把n+1之后的packet都重发一遍，如0,1,2,3,4，1未成功，GBN协议会返回1再次发送，把1,2,3,4都发送一遍
  - GBN的发送方只**设置一个定时器**，即最老的未确认分组的定时器，当定时器Timeout，**重传所有**未确认的分组
  - GBN优点是简单，所需资源少；缺点是一旦出错，回退N步代价较大
  - GBN适合出错率低的场景
  - SR接收窗口大小＞1，接收端可以乱序接收；发送端选择性重发，一旦1未成功，而0,2,3,4已收到ACK确认，会只重发1
  - SR的发送方为**每个未确认的分组都设置一个定时器**，当定时器Timeout时，只发送未确认的分组。
  - SR优点是出错时重传代价小；缺点是复杂、接收方需要多个缓存单元
  - SR适合链路容量大（延迟高、带宽大）的场景

GBN的状态机：

- 发送方

![image-20250228165648669](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228165648669.png)

接收方

- 只发送顺序接收到的最高序号分组的ACK
- 只用一个变量表示滑动窗口
- 对乱序的分组丢弃（不缓存）

![](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228165833569.png)

GBN的运行过程

![image-20250228170449281](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228170449281.png)

SR的状态机：

![image-20250228171517758](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228171517758.png)

在GBN（Go-Back-N）和SR（Selective Repeat）协议中，窗口大小的限制与序列号的位数（N）密切相关，目的是避免接收方混淆新旧分组。

GBN协议

- 窗口大小限制：GBN的发送窗口大小不能超过 2^N-1。
- 原因：GBN使用累积确认，接收方只按序确认分组。如果窗口大小达到 2^N，发送方在收到确认前可能重传与之前相同序列号的分组，导致**接收方无法区分新旧分组**。因此，窗口大小必须小于 2^N，通常为 2^N-1。

SR协议

- 窗口大小限制：SR的发送窗口和接收窗口大小都不能超过 2^(N-1)。
- 原因：SR允许接收方缓存乱序到达的分组，并单独确认。如果窗口大小超过 2^(N-1)，发送方和接收方的窗口可能**重叠**，导致接收方无法区分新旧分组。因此，窗口大小限制为  2^(N-1)，确保窗口不重叠。

![](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228175349431.png)

### 拥塞控制原理
