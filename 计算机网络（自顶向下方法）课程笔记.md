# 计算机网络（自顶向下方法）课程笔记

课程地址：[【中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程】](https://www.bilibili.com/video/BV1JV411t7ow)

## 网络概述

### 网络边缘

### 网络核心

### 接入网和物理媒体

### 因特网结构和ISP

### 分组演示、丢失和吞吐量

### 协议层次和服务模型

### 互联网历史

## 应用层

### Web和HTTP

### FTP

### EMail

### DNS

### P2P

### CDN

CDN（Content Distribution Networks）

背景：服务器如何通过网络向上百万用户同时提供流化视频内容？

选择1：单个的、大的超级服务中心——Mega Server

- 服务器到客户端路径上Hop多，瓶颈链路带宽小
- 二八定律（同一个视频的多个拷贝）
- 单点故障、性能瓶颈
- 周边网络拥塞

选择2：通过CDN，全网部署缓存节点，就近为用户提供内容加速服务

- ICP购买CDN运营商的服务，将内容提前部署于缓存节点，用户通过域名**重定向**找到最近的缓存节点（网络拥塞，可能寻找其他节点）；部署有两种策略：

  - enter deep：将CDN服务器深入接入网，数量多、离用户近；

  - bring home：部署在少数（10个左右）关键位置（安装于ISP POP附近）；采用租用线路将服务器簇链接起来

### Socket

套接字：应用进程与端到端传输协议（TCP或UDP）之间的**门户**

TCP Socket

TCP/IP：应用进程使用Socket API访问传输服务；位于层间接口的服务访问点（SAP）

```
struct socketaddr_in {
	short sin_family; // 地址簇
	u_short sin_port; // 端口
	struct in_addr sin_addr; // IP地址
	char sin_zero[8]; // 对齐 
}

// 作为调用域名解析函数时的参数
struct hostend {
	char *h_name; // 主机域名
	char **h_aliases; // 域名别名
	int h_addrtype; // 地址类型
	int h_length; // 地址长度
	char **h_addr_list; // IP地址
}
```

服务端：

绑定ip地址和端口号

welcome socket守候在某个端口，等待客户端连接

客户端连接之后返回一个connectionSocket作为会话标志

// TODO C语言代码



客户端：
隐式绑定ip地址和端口号

指定服务器的ip地址和端口号进行连接

连接之后返回一个connectionSocket作为会话标志

// TODO C语言代码



UDP Socket

客户端和服务端之间没有建立连接、没有握手

发送端在每一个报文中指定接受端的ip地址和端口号

接收端必须从收到的分组中提取出发送端的IP地址和端口号

// TODO 服务端C语言代码

// TODO 客户端C语言代码

## 传输层

### 传输层服务

为运行在不同主机上的应用进程提供逻辑通信

传输协议运行在端系统，可选择不同的协议（如TCP和UDP）

- 发送方将应用层的报文分成报文段，传递给网络层
- 接受方将报文段重组成报文，传递给应用层

传输层依赖网络层的服务，并对网络层的部分服务进行增强（数据丢失、乱序、加密可以增强，延时和带块不可增强）

可靠的保序的传输（字节流）：TCP

- 多路复用、解复用
- 拥塞控制
- 流量控制
- 建立连接

不可靠不保序的传输（数据报）：UDP

- 多路复用、解复用

### 多路复用和解服用

TCP的复用和解复用

复用：

应用层往下交TCP Socket和消息本身，TCP Socket包含源IP、源Port、目标IP、目标Port；

TCP层把源Port和目标Port和消息一起封装成TCP的段（Segment），和源IP、目标IP一起往下交

IP层拿到TCP的段（Segment）和源IP、目标IP后，封装成IP的段，传给网络层



解复用：

IP层把数据部分（即TCP的段）和源IP、目标IP一起交给TCP层

TCP层根据头部的**源Port、目标Port**和IP层传来的源IP、目标IP，从表格中查询到对应的Socket和PID

根据PID知道是哪个应用进程，把消息传给应用进程



UDP的复用和解复用

复用：

应用层往下交1.UDP Socket（TCP Socket包含源IP、源Port）、2.消息本身和3.目标IP和目标Port；

UDP层把**源Port、目标Port**和消息一起封装成UDP段（报文），和源IP、目标IP一起往下交

IP层拿到UDP的报文和源IP、目标IP后，封装成IP的段传给网络层



解复用：

IP层把数据部分（即UDP的报文）和源IP、目标IP一起交给UDP层

UDP层根据传上来的目标IP和报文中的目标Port，从表格中查询到对应的Socket和PID

根据PID知道是哪个应用进程，把消息传给应用进程



UDP可以一对多，TCP只能一对一

![image-20250228120236034](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228120236034.png)

![image-20250228120209794](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228120209794.png)

Socket的作用：使得穿过层间的信息最少

复用（在发送方主机多路复用）：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号，给报文段加上头部信息加以封装（头部信息用于以后解复用）

解复用（接收方主机多路解复用）：根据报文段头部信息的IP地址和端口号将接收到的报文段发给正确的套接字和对应的应用进程

### 无连接传输

UDP数据报的格式：

- 头部：由四个字段组成，每个字段占2字节，总长度为8字节
  1. **源端口（Source Port）**：
     - 2字节，标识发送方的端口号。
     - 可选，若不使用则置为0。
  2. **目的端口（Destination Port）**：
     - 2字节，标识接收方的端口号。
  3. **长度（Length）**：
     - 2字节，表示整个UDP报文的长度，包括头部和数据部分。
     - 最小值为8（仅头部），最大值为65535。
  4. **校验和（Checksum）**：
     - 2字节，用于检测数据在传输中的错误。
     - 在IPv4中可选，若未计算则置为0；在IPv6中强制使用。
- 应用程序数据（载荷）

![image-20250228121110656](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228121110656.png)

UDP存在的必要性：

简单，发送端和接收端没有连接状态

报文头部小

可以尽可能快的发送



校验和如何工作：

发送方计算校验和

- 数据分块：将数据划分为16位（2字节）的块。
- 求和：对这些块进行二进制求和（进位回滚）。
- 取反码：将求和结果取反码，得到校验和（EDC）。
- 插入校验和：将计算出的校验和插入到报文的校验和字段中。

接收方验证校验和

- 数据分块：同样将数据划分为16位块，包括校验和字段。
- 求和：对这些块（包含校验和）进行二进制求和（进位回滚）+取反码。
- 检查结果：若结果不为0，数据一定有误，报文被丢弃；结果为0，数据基本正确，但有可能存在残存差错（Residual Error）

伪头部（UDP/TCP）

- 增强校验：UDP和TCP在校验和计算中加入伪头部，包含源IP、目的IP、协议类型和长度等信息，确保这些字段未被篡改。

### 可靠数据传输

可靠数据传输（RDT）：信道的不可靠特点决定了可靠数据传输协议的复杂性

![image-20250228140358743](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228140358743.png)

使用有限状态机（FSM）描述发送方和接收方

RDT1.0：在可靠信道上的可靠数据传输；什么都不敢，封装、解封装

下层的信道是完全可靠的

- 没有比特出错
- 没有分组丢失

发送方和接收方的有限状态机

- 发送方将数据发送到下层信道
- 接收方从下层信道接收数据

![image-20250228141523559](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228141523559.png)

RDT2.0：停止等待协议（Stop-and-Wait）

具有比特差错的信道->下层信道可能会出错，将分组中的比特翻转

1. 用校验和来检测比特差错

问题：怎样从差错中恢复？

- 确认（ACK）：接收方显式地告诉发送方分组已被正确接收
- 否定确认（NAK）：接收方显式地告诉发送方分组发生了差错，发送方收到NAK后重新发送分组

发送方发完之后要留个副本，用于检错重传

采用差错控制编码（EDC）判断分组是否有差错

![image-20250228142248602](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228142248602.png)

RDT2.1：

发送方处理出错的ACK/NAK（ACK或NAK corrupt了）

- 给packet编号，如果收到的不是ACK或NAK，就重发上次packet

![image-20250228143452765](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228143452765.png)

接收方要给ACK和NAK也加EDC（差错控制编码）

等待n+1号packet时（说明之前已经收到过n号packet）：

- 再次收到没出错的n号packet，把收到的n号packet丢弃，并发送一个ACK
- 再次收到出错的packet，就发送一个NAK
- 收到没出错的n+1号packet，解封装、向上层传递数据，然后发送一个ACK，进入等待n+2号packet的状态

![image-20250228144918614](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228144918614.png)

细节：

发送方：

- 在分组中加入序列号，如果一次只发送一个未经确认的分组，用两个序列号（0和1）就够了
- 必须检测ACK/NAK是否出错（给ACK/NAK加EDC）
- 状态数变成了原来的两倍，因为需要记当前分组的序列号是0还是1

接收方：

- 必须检测收到的分组是否是重复的，状态会指示希望收到的分组需要是0还是1
- 接收方并不知道发送方是否正确收到了ACK/NAK

![image-20250228145326782](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228145326782.png)

RDT2.2：没有NAK的协议（NAK Free）

功能同RDT2.1，但只使用ACK（且ACK需要编号）

- 接收方对**最后**正确接收的分组发ACK，以代替NAK；接收方发的ACK必须显示地包含被正确接收的分组的序号
  - 比如接收方收1号packet出错，不是发NAK1，而是发ACK0，表示1号packet接收出错，这样就不需要NAK了

- 当发送方重复收到ACK（如再次收到ACK0）时，发送方重传当前分组

![image-20250228150730206](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228150730206.png)

![image-20250228150329573](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228150329573.png)

![image-20250228150347614](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228150347614.png)

- 为后面一次发送多个数据单位（pipeline协议）做准备
  - 一次能发送多个数据包
  - 使用对前一个数据单位的ACK，代替本数据单位的NAK
  - 优点是确认信息减少一半，协议处理简单

RDT3.0：超时重传机制

原因：下层信道可能会丢失分组（ACK丢失或packet丢失）

- 造成死锁
- 目前的机制（检验和、序列号、ACK、重传）还不够处理这种状况

解决方法：

- 发送端超时重传，每次发送分组后**启动**计时器，如果超过Timeout，就重传分组并**重置计时器**
- 收到正确的包之后关闭计时器，在计时器关闭期间不理会收到的包
- 数据链路层的Timeout时间是确定的，传输层的Timeout时间是适应性的（动态计算）

发送方：

细节：和RDT2.2不同，收到上一个packet的ACK之后，并不会立即重传，而是“按兵不动”，等待超时，因为超时了也会重传

![image-20250228152150044](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228152150044.png)

超时计时器需要设置合理的Timeout，Timeout设置太短，也能正常工作，但是效率较低，会重复发送PKT和ACK

![image-20250228152931295](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228152931295.png)

RDT3.0的性能

RDT3.0可以工作，但信道容量较大的情况下，一次发一个PDU不能够充分利用链路的传输能力，瓶颈在于网络协议限制了物理资源的利用

流水线协议：允许发送方在**未得到对方确认**的情况下一次发送多个分组

- 必须增加序号的范围，用多个bit表示分组序号
- 发送方/接收方要有缓冲区
  - 发送方缓冲：未得到确认，可能需要重传分组
  - 接收方缓冲：1.上层用户取用数据的速率≠接收到的数据速率；2.接收到的数据可能乱序，需要排序后交付

![image-20250228154208792](C:\Users\jiangruiyuan\AppData\Roaming\Typora\typora-user-images\image-20250228154208792.png)一次发n个分组使得链路利用率提高到n倍，但U达到100%时，无法再通过增加n来提高利用率；瓶颈转移到了链路带宽



两种通用的流水线协议：回退N步（GBN）和选择重传（SR）

### 拥塞控制原理
