---
typora-root-url: ./images


---


# 计算机网络（自顶向下方法）课程笔记

课程地址：[【中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程】](https://www.bilibili.com/video/BV1JV411t7ow)

## 网络概述

### 因特网概述

从具体构成角度

- 数以亿计的、互联的计算设备
- - 主机 == 端系统
  - 主机上可运行网络应用程序
- 通信链路
- - 光线、同轴电缆、无线电、卫星
- 分组交换设备
- - 路由器和交换机，用于转发分组（packets）
- 节点
- - 主机及主机上运行的应用程序
  - 路由器、交换机等网络交换设备
- 边（通信链路）
- - 接入网链路（Access）：主机连接到互联网的链路
  - 主干链路（Backbone）：路由器之间的额链路
- 协议
- 协议就是规范、标准，控制发送和接收消息，如TCP、IP、HTTP、FTP
- 对等层实体“沟通”的标准：如交换的报文**格式和次序**，以及报文传输和接收或其他事件方面采取的**动作**

从服务角度

- 使用通信设施进行通信的分布式应用，如Web、VoIP、Email、电子商务、社交网络、分布式游戏
- 通信基础设施为APP提供的编程接口（通信服务）
  - 将发送和接收数据的APP与互联网连接起来
  - 为APP提供服务：无连接不可靠服务或面向连接的可靠服务

### 网络边缘

网络边缘是主机以及运行在主机上的应用程序。

网络边缘通信有两种模式：

- C/S模式：客户端向服务器请求并接收服务（客户端主动请求资源，服务器被动响应），如Web浏览器和服务器、Email客户端和服务器
- P2P模式：没有专门的服务器，或者说每个主机同时是客户端和服务器，如Gnutella、KaZaA、Emule

TCP协议——传输控制协议

- 可靠地、保序地传输数据，会确认和重传
- 流量控制，发送方不会淹没接收方
- 拥塞控制，当网络拥塞时，发送方降低发送速率

UDP协议——用户数据报协议

- 无连接
- 不可靠地、不保序地数据传输
- 无流量控制
- 无拥塞控制

使用TCP的应用：HTTP（Web）、FTP、Telnet（远程登录）、SMTP（邮件）

使用UDP的应用：流媒体、远程会议、DNS、Internet电话

### 网络核心

网络核心是路由器构成的网状网络，数据有两种传输方式：

- 电路交换（Circuit Switch）：为每个呼叫预留一条专有电路，如电话网

  - 独享资源，每个呼叫一旦建立起来就能保证性能

  - 如果呼叫没有数据发送，被分配的资源就会浪费

  - 电路交互不适合计算机之间的通信

    - 连接建立时间长
    - 计算机之间的通信有突发性，使用电路交换则浪费的片较多
    - 可靠性不高

  - 网络资源被分成**片**，有频分（Frequency Division）、时分（Time Division）、波分，为呼叫分配片，如果某呼叫没有数据，则其资源片处于空闲状态（不共享）

    ![image-20250303143622869](/image-20250303143622869-1740983801829-1-1740996481310-73.png)

- 分组交换：以分组为单位进行存储、转发

  - 网络带宽资源不在分为片，传输时使用**全部带宽**，采用**统计多路复用**

  - 将要传输的数据分成一个个单位（分组）

  - 将分组从一个路由器传到相邻路由器（Hop）一段段最终从源端传到目标端

  - 在转发之前，节点必须受到**整个分组**

  - 排队延迟和丢失：如果分组到达速率高于链路传输速率，分组会排队等待传输；如果路由器缓存用完了，分组会被抛弃

    ![image-20250228183648092](/image-20250228183648092-1740996481308-38.png)

网络核心的关键功能

- 路由：用路由算法决定分组采用的从源到目标的路径

  ![image-20250228183853493](/image-20250228183853493-1740996481308-39.png)

- 转发：将分组从路由器的输入链路转移到输出链路

数据报（Datagram）的工作原理

- 通信之前无需建立起连接，有数据就传输
- 每一个分组都独立路由（由于路径不一样，可能会失序）
- 路由器根据分组的目标地址进行路由

虚电路（Virtual Circuit）的工作原理

在数据传输前，发送方和接收方之间通过信令协议建立一条逻辑连接。网络节点根据路由算法选择路径，并预留资源（如带宽、缓冲区）。建立完成后，网络会分配一个虚电路标识符（VCI），用于标识该连接。

### 接入网

怎样将端系统和边缘路由器连接？

- 住宅接入网络

  - Modem：将上网数据**调制**加载到音频信号上，在电话线上传输，端系统将数据解调出来；拨号调制解调器以56kbps的速率直接接入路由器，不能同时上网和打电话
    - 调幅
    - 调频
    - 调相位
    - 综合调制
  - 数字用户线路（DSL）：一种通过普通电话线提供高速互联网接入的技术
    - 它利用电话线中的高频段传输数据，不影响低频段的语音通信，因此可以同时上网和打电话
    - DSL线路上的数据被传到互联网（4khz以上），语音被传到电话网（4khz以下）
    - 分给数据的线路分为上行和下行
  - 线缆网络：
    - 有线电视信号线缆双向改造，在不同频段传输不同信道的数据，数字电视和上网数据（上下行）
    - HFC：线缆和光纤将家庭用户接入到ISP路由器，各用户贡献到线缆头端的接入网络

  ![image-20250228185834124](/image-20250228185834124-1740996481308-40.png)

- 单位接入网络

  - 端系统直接接到以太网交换机上

  ![image-20250228190048390](/image-20250228190048390-1740996481308-41.png)

- 无线网络

  - WLAN：建筑物内部
  - 广域无线接入：由电信运营商提供

### 物理媒体

导引性媒体：信号沿着固体媒介被导引，如同轴电缆、光纤、双绞纤

- 同轴电缆：两根同轴地铜导线、双向
  - 基带电缆：电缆上有单个信道
  - 宽带电缆：电缆上有多个信道
- 光纤和光缆：光脉冲，一个脉冲代表1bit，高速、低误码率、安全

非导引性媒体：信号自由传播，如无线电

- 开放空间传输电磁波无需物理线缆
- 传播环境效应：反射、吸收、干扰
- 类型：地面微波、LAN（WiFi）、wide-area（蜂窝）、卫星

### 因特网结构和ISP

ISP（Internet Service Provider）即互联网服务提供商，是向用户提供互联网接入和服务的公司或组织。

主要服务包括：

1. 互联网接入：通过宽带、光纤、DSL、无线等方式连接互联网。
2. 电子邮件和网页托管：提供电子邮箱和网站托管服务。
3. 虚拟专用网（VPN）：提供安全的远程访问服务。
4. 云服务：提供数据存储、备份等云服务。
5. 技术支持：提供网络设置、故障排除等帮助。

类型

1. 拨号ISP：通过电话线接入，速度较慢。
2. 宽带ISP：提供高速连接，如DSL、光纤等。
3. 无线ISP：通过无线技术提供接入。
4. 卫星ISP：通过卫星为偏远地区提供连接。

端系统通过**接入ISP**链接到互联网，接入ISP是互相连接的

每个ISP都连接到全局ISP（global ISP），接入ISP和全局ISP往往有经济合约

- 对等连接：

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301015102123.png)

- IXP（Internet Exchange Point）即互联网交换点，是不同网络服务提供商（ISP）和内容分发网络（CDN）之间交换流量的物理基础设施：

![image-20250301015153250](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301015153250.png)

业务细分为全球接入和区域接入，区域网络出现，用于将接入ISP连接到全局ISP

![image-20250301015316289](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301015316289.png)

ICP（Internet Content Provider）即互联网内容提供商，是指在互联网上提供各类信息、服务或应用的公司或组织。它们通过网站、应用程序等平台向用户提供内容。

主要类型

1. 新闻门户：如新浪、搜狐，提供新闻资讯。
2. 视频平台：如优酷、爱奇艺，提供视频内容。
3. 社交网络：如微信、微博，提供社交服务。
4. 电子商务：如淘宝、京东，提供在线购物。
5. 搜索引擎：如百度、Google，提供信息检索。

ICP为了减少运营支出、给用户提供更好的服务，会在全球各地部署数据中心机房，用专线连接在一起，数据中心机房往往靠近核心ISP的路由设备

![image-20250301020120329](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301020120329.png)

### 分组延时、丢失和吞吐量

在路由缓冲区有分组队列，分组等待排到队头被传输

四种延时：

- 节点处理延时：检查bit级差错，检查分组头部并决定将分组导向何处
- 排队延时：排队延时：在输出链路上等待传输的时间，依赖于路由器的拥塞程度
- 传输延时：L/R，其中R是链路带宽（bps），L是分组长度（bits）
- 传播延时：d/s，d是物理链路的长度，s是媒介传输速度

流量强度：I=La/R，流量强度不能超过1

分组丢失：由于链路的队列缓冲区容量有限，当分组到达一个满的队列时，该分组会丢失。

丢失的分组可能会被前一个节点或端系统重传，或根本不重传。
吞吐量：在源端和目标端之间的传输速率（数据量/单位时间）

- 瞬间吞吐量
- 平均吞吐量

![image-20250301125223409](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250301125223409.png)

瓶颈链路：端到端的路径上，限制端到端吞吐的链路

### 协议层次和服务模型

层次化方式实现复杂网络功能：

- 将网络复杂的功能分成功能明确的分层次，每一层实现其中一组功能，功能中有其上层可以使用的功能：服务
- 本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务
- 在实现本层协议的时候，直接利用了下层所提供的服务

服务（Service）：下层实体向上层实体提供的它们之间通信的能力

原语（Primitive）：上层使用下层服务的形式，上层使用下层提供的服务以及下层向上层提供服务的都是通过服务访问原语来进行交互的

服务访问点（Services Access Point）：上层使用下层提供的服务通过的层间接口，用于下层服务区分不同的上层用户

- 传输层的SAP：端口
- 邮箱的SAP：地址

服务分为面向连接的服务和无连接的服务

- 面向连接的服务（Connection Oriented Service）：建立连接、通信、拆除连接，网络层的连接成为虚电路，适合传输大的数据块
- 无连接的服务（Connectionless Service）：两个对等层实体在通信前不需要建立连接，适用于传输

数据单元（Data Unit）

服务数据单元（Service Data Unit）

协议数据单元（Protocal Data Unit） = 头部 + 服务数据单元；如果SDU很大，可能被拆成多份；如果SDU很小，可能和多个SDU合成一份

- 应用层的PDU叫消息（Message），传输层的PDU叫段（Segment），网络层的PDU叫分组（有连接，Packet）或数据报（无连接，Datagram）；数据链路层的PDU叫帧（Frame）

分层处理和实现复杂系统的好处：

- 概念化：结构清晰，便于标示网络组件及其相互关系
- 结构化：模块更易于维护和升级，改变某一层的服务实现不影响系统中的其他层次

互联网协议栈

- 应用层：为应用进程提供网络应用服务，FTP、SMTP、HTTP、DNS
- 传输层：在网络层提供的端到端通信基础上，细分为**进程到进程**的通信，TCP和UDP
- 网络层：为数据报从源主机到目标主机选择路由，传输以**分组**为单位的**端到端**的数据，IP、路由协议
- 链路层：**相邻2个**网络节点之间传输以**帧**为单位的数据，点对点协议、802.11（WiFi）、Ethernet
- 物理层：在线路上传输bit

路由器做三层（网络层、链路层、物理层）的封装和解封装，交换机做两层（链路层、物理层）的封装和解封装

OSI模型，多了表示层和会话层，互联网协议栈没有这两层

应用层、表示层、会话层、传输层、网络层、链路层、物理层

表示层：允许应用解释传输的数据，加密、压缩、机器相关的表示转换

会话层：数据交换的同步、检查点、恢复

### 互联网历史

1960年之前，计算机网络采用线路交换。有三个小组独立开展分组交换的研究：

- 1961：Kleinrock（MIT）
- 1964：Baran（美国兰德）
- 1964：Donald（英国）

1961-1972：早期的分组叫唤概念

- 1967：美国高级研究计划研究局考虑ARPAne
- 1961：第一个ARPAnet节点开始工作
- 1969：4个节点
- 1972：ARPAnet公众演示、第一个email程序、有15个节点

1972-1980：专用网络和网络互联

1980-1990：体系结构变化，网络数量激增，应用丰富

- 1983：TCP/IP部署、DNS定义
- 1982：SMTP协议定义
- 1985：FTP协议定义、OSI模型提出
- 1988：TCP拥塞控制

1990-200：商业化、Web、新应用

## 应用层

### Web和HTTP

Web：由一些对象组成，对象可以是HTML文件、JPEG图像、Java小程序、MP3文件等

Web页有一个基本的HTML文件，该文件包含若干对象的引用（链接），每个对象可以通过统一资源定位符（URL）访问

URL格式：Prot: // user:pwd@www.someSchool.edu/someDept/pic.gif:port

- 协议名称: // 用户:口令@主机名/路径名/端口，HTTP协议默认80号端口，FTP协议默认21号端口

HTTP协议：超文本传输协议

属于Web应用层协议，采用C/S模式

- 客户端即浏览器请求、接收和渲染Web对象
- 服务器对请求进行响应，发送对象

HTTP协议基于TCP协议：

- 客户端发起一个与服务器的TCP连接（建立套接字），服务端接受客户端的连接
- 在浏览器与Web服务器交换HTTP报文（应用层报文）
- TCP连接关闭

HTTP是无状态的，服务器不维护关于客户的任何信息

非持久HTTP（HTTP1.0）

- 最多只有一个对象在TCP连接上发送
- 下载多个对象需要多个TCP连接
- 方法：GET、POST、HEAD
- 非持久HTTP的缺点：
  - 每个对象要两个RTT（建立连接和传输数据各一个）
  - 操作系统必须为每个TCP连接分配资源

持久HTTP（HTTP1.1默认）

- 多个对象可以在一个客户端和服务器之间的TCP连接上传输

- 服务器在发送响应后仍保持TCP连接，后续请求和响应报文通过相同连接进行传送
- 客户端在遇到一个引用对象时就尽快发送该对象的请求
- 方法：GET、POST、HEAD、PUT（将实体主体中的文件尚在到URL字段规定的路径）、DELETE（删除URL字段规定的文件）
- 持久型连接分为流水线模式和非流水线模式
  - 非流水线模式：客户端在收到前一个请求的响应后再发送新的请求
  - 流水线模式（HTTP1.1默认）：客户端遇到一个引用对象就立刻发送一个请求

HTTP请求报文的格式：

![image-20250302005729341](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250302005729341.png)

HTTP响应报文的格式：

- 状态码
- 首部行（包含Content-Length，因为TCP不维护报文边界）
- 数据

![image-20250302010241736](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250302010241736.png)

状态码：位于服务器发给客户端的响应报文的首行

- 200 OK
- 301 Moved Permanently
- 400 Bad Request
- 404 Not Found
- 505 HTTP Version Not Supported

### FTP

文件传输协议（FTP）：向远程主机上传输文件或从远程主机接受文件

- C/S模式
  - 客户端：发起传输的一方
  - 服务器：远程主机
- 默认端口是21（控制连接）和20（数据连接）

FTP控制连接和数据连接分开

- 客户端通过控制连接获得身份确认

- 客户端通过控制连接发送命令浏览远程目录
- 收到一个文件传输命令时，服务器主动建立一个到客户端的数据连接
- 一个文件传输完成后，服务器关闭连接
- 带内：数据连接，传数据，带外（out of band）：控制连接，传指令
- 是有状态的协议，服务器维护客户端状态

### EMail

三个主要组成部分：

- 用户代理
  - 又名“邮件阅读器”，撰写、编辑和阅读邮件
- 邮件服务器
  - 邮箱中管理和维护发送给用户的右键
  - 输出的报文队列保持待发送邮件报文
  - 通过SMTP协议发送邮件报文
- 邮件传输协议

![image-20250303104426879](/image-20250303104426879-1740996481308-42.png)

简单邮件传输协议（SMTP）

- 使TCP协议在客户端和服务器之间传输报文，端口为25
- 传输分为握手、传输报文、关闭连接三个节点
- 命令是ASCII码文本，响应是状态码和状态信息，也是ASCII码文本

邮件报文格式：多媒体邮件扩展（MIME，Multimedia Mail Extension）

- 在报文首部用额外的行声明MIME内容类型

![image-20250303105426575](/image-20250303105426575-1740996481308-43.png)

邮件访问协议：从邮件服务器访问邮件，有POP协议、IMAP协议、HTTP协议

- POP：邮局访问协议（Post Office Protocal），用户确认身份并下载
  - POP协议在会话中是无状态的
  - 本地管理文件夹
- IMAP：Internet邮件访问协议（Internet Mail Access Protocol），更多特性、在服务器上处理存储的报文
  - IMAP服务器将每个报文与一个文件夹联系起来，允许用户用目录来组织报文
  - IMAP在会话过程中保留用户状态（目录名、报文ID与目录名之间的映射）
- HTTP协议：方便，Hotmail、Yahoo Mail使用这种协议

### DNS

域名系统（Domain Name System）的必要性

- IP地址标识主机和路由器，但不好记忆、不便人类使用
- 人类一般倾向于使用一些有意义的字符串来表示互联网的设备，如www.baidu.com所在的Web服务器
- 存在着从**域名到IP地址的转换**的必要性

DNS的实现方式

- **分层**的、基于域的命名机制
- 若干**分布式**的数据库完成名字到IP地址的转换
- 运行在**UDP**之上的端口号为53的应用服务

DNS的功能

- 主要功能是实现域名到IP地址的转换
- 其他功能还有：主机别名（便于用户访问）到规范名字（便于管理）的转换（Host Aliasing）、邮件服务器别名到邮件服务器正规名字的转换（Mail Server Aliasing）、负载均衡（Load Distribution）

DNS域名结构：采用层次树状结构命名

- 顶级域（Top Level Domains）：.com、.edu、.org、.cn、.us、.jp等
- 子域（Subdomains）
- 叶子节点是主机

![image-20250303113005037](/image-20250303113005037-1740996481308-44.png)

根名字服务器（Root Name Server）：用于管理顶级域的地址信息，全球共有13个根名字服务器，确保DNS查询可靠性

域名的管理：

- 一个域管理其下的子域，如.cn被划分为edu.cn、com.cn等

- 创建一个新的域必须征得它所属域的同意
- 域的划分和物理网络无关

区域（Zone）

- 将DNS名字空间划分为**互不相交**的区域
- 每个区域都有一个权威名字服务器（Authoritative Record）维护它所管辖区域的权威信息，上层域的名字服务器中有指针指向下层域的名字服务器（NS记录）
- 权威名字服务器允许被放置在区域之外，以保障可靠性
- 对于权威名字，组织机构可以选择自己维护或某个服务提供商来维护

DNS记录：保存资源记录（RR）的分布式数据库

- RR格式：（name, value, type, ttl）
- Type = A：Name为主机，Value为IP地址
- Type = NS：Name为子域的域名，Value为子域的权威名字服务器的域名
- Type = CNAME：Name为规范名字的别名（www.ibm.com），Value为规范名字（servereast.backup2.ibm.com）
- Type = MX：Name为邮件服务器的别名，Value为邮件服务器的规范名字
- TTL：生存时间决定是缓冲记录还是权威记录

DNS工作过程：

- 应用调用解析器（Resolver）
- 解析器作为客户端向Name Server发送查询报文，报文封装在UDP段中
- Name Server返回响应报文

本地名字服务器（Local Name Server）

- 并不严格属于层次结构

- 每个ISP都有一个本地名字服务器，也称“默认名字服务器”

- 当主机发起一个DNS查询时，查询被发送到其本地名字服务器

- 起着代理作用，将查询转发到层次结构中

- 名字解析过程：

  - 目标名字在本地名字服务器中：查询的名字在该区域内部或有缓存

  - 目标名字不在本地名字服务器中：

    - 递归查询：联系根名字服务器，顺着根的顶级域名服务器一直找到权威名字服务器

    ![image-20250303120514342](/image-20250303120514342-1740996481308-45.png)

    - 迭代查询：服务器返回的不是查询结果，而是下一个NS的地址，最后由权威名字服务器给出解析结果

    ![image-20250303120748555](/image-20250303120748555-1740996481308-46.png)



### P2P

纯P2P架构：没有（或极少）一直运行的服务器

- 任意端系统都可以直接通信
- 利用Peer的服务能力
- Peer节点间歇上网，每次IP地址都有可能变化
- 例子：文件分发、流媒体、VoIP

非结构化P2P

结构化P2P（DHT）

P2P可以有：

- 集中式目录服务器，问题：单点故障、性能瓶颈、侵犯版权
- 完全分布式，泛洪式查询（广度优先搜索）
- 混合式：每个对等方要么是一个组长，要么隶属于一个组长，对等方与组长之间有TCP链接，组长对之间有TCP链接；组长跟踪其所有组员的内容，组员向组长发起请求，如果组内有，组长直接返回资源，如果组内没有，组长转发查询给其他组长，获得其他组的数据

BitTorrent文件分发

- 向跟踪服务器（Tracking Server）注册，获得peer节点列表，和部分peer构成链接关系
- 一开始没有块，但会通过其他节点积累文件块，优先请求稀缺的块
- peer下载时可以同时向其他peer提供上载服务
- peer节点可能会上线获下线
- “优化疏通”（Tit for Tat）和随机选择

### CDN

CDN（Content Distribution Networks）

背景：服务器如何通过网络向上百万用户同时提供流化视频内容？

选择1：单个的、大的超级服务中心——Mega Server

- 服务器到客户端路径上Hop多，瓶颈链路带宽小
- 二八定律（同一个视频的多个拷贝）
- 单点故障、性能瓶颈
- 周边网络拥塞

选择2：通过CDN，全网部署缓存节点，就近为用户提供内容加速服务

- ICP购买CDN运营商的服务，将内容提前部署于缓存节点，用户通过域名**重定向**找到最近的缓存节点（网络拥塞，可能寻找其他节点）；部署有两种策略：

  - enter deep：将CDN服务器深入接入网，数量多、离用户近；

  - bring home：部署在少数（10个左右）关键位置（安装于ISP POP附近）；采用租用线路将服务器簇链接起来

### Socket

套接字：应用进程与端到端传输协议（TCP或UDP）之间的**门户**

TCP Socket

TCP/IP：应用进程使用Socket API访问传输服务；位于层间接口的服务访问点（SAP）

```
struct socketaddr_in {
	short sin_family; // 地址簇
	u_short sin_port; // 端口
	struct in_addr sin_addr; // IP地址
	char sin_zero[8]; // 对齐 
}

// 作为调用域名解析函数时的参数
struct hostend {
	char *h_name; // 主机域名
	char **h_aliases; // 域名别名
	int h_addrtype; // 地址类型
	int h_length; // 地址长度
	char **h_addr_list; // IP地址
}
```

服务端：

绑定ip地址和端口号

welcome socket守候在某个端口，等待客户端连接

客户端连接之后返回一个connectionSocket作为会话标志

// TODO C语言代码



客户端：
隐式绑定ip地址和端口号

指定服务器的ip地址和端口号进行连接

连接之后返回一个connectionSocket作为会话标志

// TODO C语言代码



UDP Socket

客户端和服务端之间没有建立连接、没有握手

发送端在每一个报文中指定接受端的ip地址和端口号

接收端必须从收到的分组中提取出发送端的IP地址和端口号

// TODO 服务端C语言代码

// TODO 客户端C语言代码

## 传输层

### 传输层服务

为运行在不同主机上的应用进程提供逻辑通信

传输协议运行在端系统，可选择不同的协议（如TCP和UDP）

- 发送方将应用层的报文分成报文段，传递给网络层
- 接受方将报文段重组成报文，传递给应用层

传输层依赖网络层的服务，并对网络层的部分服务进行增强（数据丢失、乱序、加密可以增强，延时和带块不可增强）

可靠的保序的传输（字节流）：TCP

- 多路复用、解复用
- 拥塞控制
- 流量控制
- 建立连接

不可靠不保序的传输（数据报）：UDP

- 多路复用、解复用

### 多路复用和解服用

TCP的复用和解复用

复用：

应用层往下交TCP Socket和消息本身，TCP Socket包含源IP、源Port、目标IP、目标Port；

TCP层把源Port和目标Port和消息一起封装成TCP的段（Segment），和源IP、目标IP一起往下交

IP层拿到TCP的段（Segment）和源IP、目标IP后，封装成IP的段，传给网络层



解复用：

IP层把数据部分（即TCP的段）和源IP、目标IP一起交给TCP层

TCP层根据头部的**源Port、目标Port**和IP层传来的源IP、目标IP，从表格中查询到对应的Socket和PID

根据PID知道是哪个应用进程，把消息传给应用进程



UDP的复用和解复用

复用：

应用层往下交1.UDP Socket（TCP Socket包含源IP、源Port）、2.消息本身和3.目标IP和目标Port；

UDP层把**源Port、目标Port**和消息一起封装成UDP段（报文），和源IP、目标IP一起往下交

IP层拿到UDP的报文和源IP、目标IP后，封装成IP的段传给网络层



解复用：

IP层把数据部分（即UDP的报文）和源IP、目标IP一起交给UDP层

UDP层根据传上来的目标IP和报文中的目标Port，从表格中查询到对应的Socket和PID

根据PID知道是哪个应用进程，把消息传给应用进程



UDP可以一对多，TCP只能一对一

![image-20250228120236034](/image-20250228120236034-1740996481308-47.png)

![image-20250228120209794](/image-20250228120209794-1740996481308-48.png)

Socket的作用：使得穿过层间的信息最少

复用（在发送方主机多路复用）：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号，给报文段加上头部信息加以封装（头部信息用于以后解复用）

解复用（接收方主机多路解复用）：根据报文段头部信息的IP地址和端口号将接收到的报文段发给正确的套接字和对应的应用进程

### 无连接传输

UDP数据报的格式：

- 头部：由四个字段组成，每个字段占2字节，总长度为8字节
  1. **源端口（Source Port）**：
     - 2字节，标识发送方的端口号。
     - 可选，若不使用则置为0。
  2. **目的端口（Destination Port）**：
     - 2字节，标识接收方的端口号。
  3. **长度（Length）**：
     - 2字节，表示整个UDP报文的长度，包括头部和数据部分。
     - 最小值为8（仅头部），最大值为65535。
  4. **校验和（Checksum）**：
     - 2字节，用于检测数据在传输中的错误。
     - 在IPv4中可选，若未计算则置为0；在IPv6中强制使用。
- 应用程序数据（载荷）

![image-20250228121110656](/image-20250228121110656-1740996481308-49.png)

UDP存在的必要性：

简单，发送端和接收端没有连接状态

报文头部小

可以尽可能快的发送



校验和如何工作：

发送方计算校验和

- 数据分块：将数据划分为16位（2字节）的块。
- 求和：对这些块进行二进制求和（进位回滚）。
- 取反码：将求和结果取反码，得到校验和（EDC）。
- 插入校验和：将计算出的校验和插入到报文的校验和字段中。

接收方验证校验和

- 数据分块：同样将数据划分为16位块，包括校验和字段。
- 求和：对这些块（包含校验和）进行二进制求和（进位回滚）+取反码。
- 检查结果：若结果不为0，数据一定有误，报文被丢弃；结果为0，数据基本正确，但有可能存在残存差错（Residual Error）

伪头部（UDP/TCP）

- 增强校验：UDP和TCP在校验和计算中加入伪头部，包含源IP、目的IP、协议类型和长度等信息，确保这些字段未被篡改。

### 可靠数据传输

可靠数据传输（RDT）：信道的不可靠特点决定了可靠数据传输协议的复杂性

![image-20250228140358743](/image-20250228140358743-1740996481308-50.png)

使用有限状态机（FSM）描述发送方和接收方

RDT1.0：在可靠信道上的可靠数据传输；什么都不敢，封装、解封装

下层的信道是完全可靠的

- 没有比特出错
- 没有分组丢失

发送方和接收方的有限状态机

- 发送方将数据发送到下层信道
- 接收方从下层信道接收数据

![image-20250228141523559](/image-20250228141523559-1740996481308-51.png)

RDT2.0：停止等待协议（Stop-and-Wait）

具有比特差错的信道->下层信道可能会出错，将分组中的比特翻转

1. 用校验和来检测比特差错

问题：怎样从差错中恢复？

- 确认（ACK）：接收方显式地告诉发送方分组已被正确接收
- 否定确认（NAK）：接收方显式地告诉发送方分组发生了差错，发送方收到NAK后重新发送分组

发送方发完之后要留个副本，用于检错重传

采用差错控制编码（EDC）判断分组是否有差错

![image-20250228142248602](/image-20250228142248602-1740996481308-52.png)

RDT2.1：

发送方处理出错的ACK/NAK（ACK或NAK corrupt了）

- 给packet编号，如果收到的不是ACK或NAK，就重发上次packet

![image-20250228143452765](/image-20250228143452765-1740996481309-53.png)

接收方要给ACK和NAK也加EDC（差错控制编码）

等待n+1号packet时（说明之前已经收到过n号packet）：

- 再次收到没出错的n号packet，把收到的n号packet丢弃，并发送一个ACK
- 再次收到出错的packet，就发送一个NAK
- 收到没出错的n+1号packet，解封装、向上层传递数据，然后发送一个ACK，进入等待n+2号packet的状态

![image-20250228144918614](/image-20250228144918614-1740996481309-54.png)

细节：

发送方：

- 在分组中加入序列号，如果一次只发送一个未经确认的分组，用两个序列号（0和1）就够了
- 必须检测ACK/NAK是否出错（给ACK/NAK加EDC）
- 状态数变成了原来的两倍，因为需要记当前分组的序列号是0还是1

接收方：

- 必须检测收到的分组是否是重复的，状态会指示希望收到的分组需要是0还是1
- 接收方并不知道发送方是否正确收到了ACK/NAK

![image-20250228145326782](/image-20250228145326782-1740996481309-55.png)

RDT2.2：没有NAK的协议（NAK Free）

功能同RDT2.1，但只使用ACK（且ACK需要编号）

- 接收方对**最后**正确接收的分组发ACK，以代替NAK；接收方发的ACK必须显示地包含被正确接收的分组的序号
  - 比如接收方收1号packet出错，不是发NAK1，而是发ACK0，表示1号packet接收出错，这样就不需要NAK了

- 当发送方重复收到ACK（如再次收到ACK0）时，发送方重传当前分组

![image-20250228150730206](/image-20250228150730206-1740996481309-56.png)

![image-20250228150329573](/image-20250228150329573-1740996481309-57.png)

![image-20250228150347614](/image-20250228150347614-1740996481309-58.png)

- 为后面一次发送多个数据单位（pipeline协议）做准备
  - 一次能发送多个数据包
  - 使用对前一个数据单位的ACK，代替本数据单位的NAK
  - 优点是确认信息减少一半，协议处理简单

RDT3.0：超时重传机制

原因：下层信道可能会丢失分组（ACK丢失或packet丢失）

- 造成死锁
- 目前的机制（检验和、序列号、ACK、重传）还不够处理这种状况

解决方法：

- 发送端超时重传，每次发送分组后**启动**计时器，如果超过Timeout，就重传分组并**重置计时器**
- 收到正确的包之后关闭计时器，在计时器关闭期间不理会收到的包
- 数据链路层的Timeout时间是确定的，传输层的Timeout时间是适应性的（动态计算）

发送方：

细节：和RDT2.2不同，收到上一个packet的ACK之后，并不会立即重传，而是“按兵不动”，等待超时，因为超时了也会重传

![image-20250228152150044](/image-20250228152150044-1740996481309-59.png)

超时计时器需要设置合理的Timeout，Timeout设置太短，也能正常工作，但是效率较低，会重复发送PKT和ACK

![image-20250228152931295](/image-20250228152931295-1740996481309-60.png)

RDT3.0的性能

RDT3.0可以工作，但信道容量较大的情况下，一次发一个PDU不能够充分利用链路的传输能力，瓶颈在于网络协议限制了物理资源的利用

流水线协议：允许发送方在**未得到对方确认**的情况下一次发送多个分组

- 必须增加序号的范围，用多个bit表示分组序号
- 发送方/接收方要有缓冲区
  - 发送方缓冲：未得到确认，可能需要重传分组
  - 接收方缓冲：1.上层用户取用数据的速率≠接收到的数据速率；2.接收到的数据可能乱序，需要排序后交付

![image-20250228154208792](/image-20250228154208792-1740996481309-61.png)一次发n个分组使得链路利用率提高到n倍，但U达到100%时，无法再通过增加n来提高利用率；瓶颈转移到了链路带宽

滑动窗口（Slide Window）协议

- 发送缓冲区
  - 形式：内存中的一个区域，落入缓冲区的分组可以发送
  - 功能：用于存放已经发送但是没有得到确认的分组
  - 必要性：需要重发时使用
- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组？
  - 停止等待协议：发送缓冲区大小==1
  - 流水线协议：发送缓冲区大小＞1，需要是合理的值，但是不能很大，链路利用率不能超过100%
    - 回退N步协议：接收缓冲区 == 1
    - 选择重传协议：接收缓冲区＞1
- 发送缓冲区中的分组：
  - 未发送的：落入发送缓冲区的分组可以连续发送出去
  - 已经发送出去的、等待对方确认的分组：只有得到确认后才可删除

发送窗口：发送缓冲区的一个子集（长度≤发送缓冲区长度），表示那些已发送但未经确认的分组的序号构成的空间

- 一开始没有发送任何一个分组
  - 后沿==前沿
  - 每发送一个分组，前沿前移一个单位
- 收到已发送分组的确认
  - 发送缓冲区整体向前移动
  - 发送窗口后沿向前移动

![image-20250228155958506](/image-20250228155958506-1740996481309-62.png)

![image-20250228160517999](/image-20250228160517999-1740996481309-63.png)

![image-20250228160633874](/image-20250228160633874-1740996481309-64.png)

过程：

![image-20250228160800059](/image-20250228160800059-1740996481309-65.png)

接收窗口：**等同于**接受缓冲区

- 用于控制哪些分组可以接受

  - 只有收到的分组序号落入接收窗口内才允许接收
  - 若序号在接收窗口外，则丢弃

- 接收窗口的滑动和发送确认

  - 滑动：
    - 最低序号的分组到来，接收窗口滑动
    - 非最低序号的分组到来（乱序），缓存但不交付，因此不滑动
  - 发送确认：
    - 接收窗口大小==1时（GBN协议），发送连续收到的最大分组的确认（累计确认）
    - 接收窗口大小＞1时（SR协议），收到哪个分组就发送哪个分组的确认（非累计确认）

- 接收窗口大小

  - 接收窗口大小==1 -> 回退N步协议（Go Back N），**只能顺序接收**

    ![image-20250228161618015](/image-20250228161618015-1740996481309-66.png)

  - 接受窗口大小 > 1 -> 选择重传协议（Selective Repeat），**可以乱序**接收，但**提交给上层的分组要按序**

    ![](/image-20250228163039478-1740996481309-67.png)

两种通用的流水线协议：回退N步（GBN）和选择重传（SR）

// 比较用表格表示

- 相同之处：
  - 发送窗口＞1
  - 一次可发多个未经确认的分组
- 不同之处：GBN中发送方每次重发会发送缓冲区中的所有分组，SR中发送方每次重发只会缓冲区中未收到确认的分组
  - GBN接收窗口大小==1；接收端只能顺序接受；发送端一旦收到ACKn，就会把n+1之后的packet都重发一遍，如0,1,2,3,4，1未成功，GBN协议会返回1再次发送，把1,2,3,4都发送一遍
  - GBN的发送方只**设置一个定时器**，即最老的未确认分组的定时器，当定时器Timeout，**重传所有**未确认的分组
  - GBN优点是简单，所需资源少；缺点是一旦出错，回退N步代价较大
  - GBN适合出错率低的场景
  - SR接收窗口大小＞1，接收端可以乱序接收；发送端选择性重发，一旦1未成功，而0,2,3,4已收到ACK确认，会只重发1
  - SR的发送方为**每个未确认的分组都设置一个定时器**，当定时器Timeout时，只发送未确认的分组。
  - SR优点是出错时重传代价小；缺点是复杂、接收方需要多个缓存单元
  - SR适合链路容量大（延迟高、带宽大）的场景

GBN的状态机：

- 发送方

![image-20250228165648669](/image-20250228165648669-1740996481309-68.png)

接收方

- 只发送顺序接收到的最高序号分组的ACK
- 只用一个变量表示滑动窗口
- 对乱序的分组丢弃（不缓存）

![](/image-20250228165833569-1740996481309-69.png)

GBN的运行过程

![image-20250228170449281](/image-20250228170449281-1740996481309-70.png)

SR的状态机：

![image-20250228171517758](/image-20250228171517758-1740996481309-71.png)

在GBN（Go-Back-N）和SR（Selective Repeat）协议中，窗口大小的限制与序列号的位数（N）密切相关，目的是避免接收方混淆新旧分组。

GBN协议

- 窗口大小限制：GBN的发送窗口大小不能超过 2^N-1。
- 原因：GBN使用累积确认，接收方只按序确认分组。如果窗口大小达到 2^N，发送方在收到确认前可能重传与之前相同序列号的分组，导致**接收方无法区分新旧分组**。因此，窗口大小必须小于 2^N，通常为 2^N-1。

SR协议

- 窗口大小限制：SR的发送窗口和接收窗口大小都不能超过 2^(N-1)。
- 原因：SR允许接收方缓存乱序到达的分组，并单独确认。如果窗口大小超过 2^(N-1)，发送方和接收方的窗口可能**重叠**，导致接收方无法区分新旧分组。因此，窗口大小限制为  2^(N-1)，确保窗口不重叠。

![](/image-20250228175349431-1740996481309-72.png)

### 面向连接的传输：TCP

TCP连接的特点

- 点对点，一个发送方，一个接收方
- 可靠的、保序的**字节流**服务，没有报文边界
- 管道化（流水线），发送方在未经确认的情况下可以连续发送多个报文
- 发送和接收缓存，发送方和接收方都有缓冲区
- 全双工通信，在同一连接中数据双向流动

TCP报文结构，其中：

- 序号：报文段首个字节在字节流中的编号，为了防止网络中旧数据影响当前通信
- 确认号：期望从另一方收到的下一个字节的序号

![image-20250303165833994](/image-20250303165833994-1740996481312-74.png)

怎样设置TCP通信的超时定时器？

- 比RTT要长，但是RTT是变化的
  - Sample RTT：测量从报文段发出到收到确认的时间，如果有重传，忽略这次测量
- 太短会引起不必要的重传；太长会对报文段的丢失反应慢
- 超时时间间隔设置为：TimeoutInterval = EstimatedRTT +4 *DevRTT
  - EstimatedRTT = (1-α)  * EstimatedRTT + α * SampleRTT，推荐α = 0.125
  - DevRTT = (1-β) * DefRTT + β|SampleRTT - EstimatedRTT|，推荐β = 0.25

TCP在IP不可靠服务的基础上建立了可靠的数据传输

- 管道化（流水线）的报文段，GBN和SR协议的混合

- 接收方给出的ACK是**累计确认**，即顺序到达的最后一个字节的期待（期望下一个收到的段的序号）（GBN）

- 发送方维护单个重传计时器（GBN）

- 是否可以接受乱序（缓存还是抛弃），没有规范

- 通过一下事件触发重传

  - 超时，只重发那个最早的未确认的字节（SR）

  - 当发送方收到3个或更多重复ACK时，会立即重传丢失的数据包（快速重传机制）

    ![image-20250303180740932](/image-20250303180740932-1740996481312-75.png)

- 接收方有一个辅助定时器...

TCP流量控制

- 应用从缓冲区中取数据，TCP实体从缓冲区中放数据
- 如果应用取数据的速度没有TCP放数据的速度快，可能会造成拥塞
- 接收方通过TCP头部的**窗口大小字段（RWND）**告知发送方其**当前可用的缓冲区空间**；发送方根据此信息调整发送窗口，确保不会发送过多数据

TCP连接为什么必须三次握手？

- 两次连接可能会有虚假半连接和数据老旧问题

![image-20250303183205792](/image-20250303183205792.png)

TCP四次挥手：对称释放两个半连接，但是并不完美

![image-20250303184921466](/image-20250303184921466.png)

### 拥塞控制原理

拥塞的定义：太多的数据需要传输，超过了网络的处理能力。

拥塞的表现：分组丢失、分组超时重发、分组经历比较长的延迟。

拥塞控制方法：

- 端到端的拥塞控制
  - 没有来自网络的显式反馈
  - 端系统根据延迟和丢失事件判断是否有拥塞
- 网络辅助的拥塞控制
  - 单个bit置位，显示有拥塞（SNA、DECbit、TCP/IP、ECN、ATM）
  - 显式提供发送端可以采用的速率（Explicit Rate）
    - 拥塞的交换机可能会降低ER的值
    - 发送端发送速率是最低可支持速率

### TCP拥塞控制

TCP的拥塞控制采用**端到端的拥塞控制机制**，即路由器不向主机反馈拥塞信息

- 路由器的负担较轻
- 复合网络核心简单的TCP/IP架构原则

端系统根据自身得到的信息判断是否发生拥塞

发送端如何检测拥塞？

- 超时（某些段的超时时间到了，但ACK还没到来）
  - 网络拥塞（某个路由器的缓冲区没有空间了，被丢弃） => 概率大
  - 出错被丢弃（没有通过各级的数据校验） => 概率小
- 有关某个段的3次重复ACK => 轻微拥塞

如何控制发送端的发送速率？

- 发送端维护一个拥塞窗口的值：CongWin，限制已发送但未确认的数据量的上限：LastByteSent - LastByteAcked ≤ CongWin
- rate = Cong/RTT
- CongWin是动态的：
  - 如果超时或收到3个重复ACK，CongWin下降
    - 超时：CongWin降为1MSS => 进入SS（慢启动）阶段，然后再倍增到CongWin/2，从而进入CA（拥塞避免）阶段
    - 3个重复ACK：CongWin降为CongWin/2 => CA阶段
  - 否则，CongWin增加
    - 慢启动（Slow-Start）阶段，每个RTT加倍增加（1，2，4，8......）
    - 拥塞避免（Congestion-Avoidance）阶段，每个RTT线性增加1个MSS
  - 总结
    - 当CongWin＜Threshold，发送端处于慢启动阶段，窗口指数增长
    - 当CongWin > Threshold，发送端处于拥塞避免阶段，窗口线性增长
    - 当收到3个重复ACK，Threshold = CongWin/2，CongWin = Threshold + 3（放3个冗余ACK），进入拥塞避免阶段
    - 当发生超时，Threshold = CongWin/2，CongWin = 1MSS，进入慢启动阶段

![image-20250306165824296](/../image-20250306165824296.png)

TCP拥塞控制和流量控制的联合动作：发送端控制发送但未确认的量的同时，也不能超过接收端的接收窗口大小，也即SendWin = Math.Min(CongWin, RecvWin)，从而同时满足流量控制盒拥塞控制的要求

TCP的公平性：如果有K个TCP会话共享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R/K => TCP的拥塞控制导致了它的公平性。

## 网络层

网络层的主要功能：

- 在发送主机和接收主机之间传送段（Segment）
- 发送端将段封装到数据报中，接收端将段上交给传输层实体
- 网络层协议存在于每一个主机和路由器
- 路由器检查每一个经过它的IP数据报的头部

转发（数据平面）：

- 本地的，每个路由器的功能
- 决定路由器输入端口到达的分组如何转发到输出端口
- 转发方式：
  - 传统方式：基于**目标主机IP地址**+转发表
  - SDN方式：基于**多个字段**+流表

路由（控制平面）：

- 全局的，网络范围内的逻辑

- 决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间端到端的路径

- 控制平面方法：

  - 传统路由算法：在路由器中实现，数据平面和控制平面**紧耦合**，控制平面算路由表，数据平面IP协议根据**目标IP和路由表**决定数据报在此路由器上的局部转发

  ![image-20250306203034581](/../image-20250306203034581.png)

  - SDN：远程服务器中实现，远程服务器与本地控制代理（CA）交互，本地控制代理根据**多个字段**对数据报进行转发、丢弃、泛洪、修改等操作

  ![image-20250306203307527](/../image-20250306203307527.png)

网络服务模型：从发送方主机到接收方主机传输数据报的通道，网络提供什么样的服务模型？

对于单个数据报的服务：

- 可靠传输
- 延迟保证

对数据报流的服务：

- 保序传达
- 保证流的最小带宽
- 分组之间的延迟差

![image-20250306204741710](/../image-20250306204741710.png)

### 路由器组成

路由器的功能：路由和转发，事实上输入端口和输出端口是整合在一起的。

![image-20250306205100320](/../image-20250306205100320.png)

输入端口缓存：由于Head-of-the-Line(HOL) blocking，排在队头的数据报组织了队列中其他数据报向前移动，因此需要**输入端口缓存**

输出端口缓存：数据报的到达速率可能比传输速率快，因此需要输出端口缓存，并不是先到先发， 而是根据**调度规则**选择队列中的数据报进行传输

- FIFO：先到先传
- 优先权调度：发送最高优先权的分组
- Round Robin（RR）：循环扫描不同类型的队列，发完一类再发下一类
- Weighted Fair Queuing（WFQ）：一般化的Round Robin，每个类在每一循环中获得不同权重的服务量

![image-20250306210253544](/../image-20250306210253544.png)

第一代路由器：

- 在CPU直接控制下交换，采用转筒的计算机
- 分组被拷贝到系统内存，CPU从分组的头部提取目标IP地址，查找转发表，找到并拷贝到输出端口
- 转发速率被内存的带宽限制且数据报需要拷贝两次
- 一次只能转发一个分组

![image-20250306210750296](/../image-20250306210750296.png)

第二代路由器：

- 数据报通过共享总线，从输入端口转发到输出端口
- 总线竞争：交换速度受限于总线的带宽
- 一次处理一个分组

![image-20250306210817986](/../image-20250306210817986.png)

第三代路由器：

- 同时并发转发多个分组，克服总线带宽限制

![image-20250306210826835](/../image-20250306210826835.png)

### IP协议

IP数据报的格式

![image-20250307114528011](/../image-20250307114528011.png)

IP分片和重组

- 网络链路有最大传输单元（MTU），不同的链路类型有不同的最大传输大院
- 大的IP数据报在网络上被分片（Fragment）成小的数据报
  - 具有相同的ID
  - 不同的偏移量
  - 最后一个分片标记为0
- “重组”只在最终的目标主机进行，目标主机设置定时器，到时后所有的分片没到齐就丢弃
- IP头部的信息被用于标识和排序相关分片

![image-20250307141316533](/../image-20250307141316533.png)

IP地址：32位，对主机或路由器接口的编址

接口：主机或路由器和物理链路的连接处

- 路由器通常拥有多个接口
- 主机也可能有多个接口
- 一个IP地址和一个接口相关联

![image-20250307141833969](/../image-20250307141833969.png)

子网（Subnet）

- 一个子网内的节点（主机或路由器），它们的IP地址的高位部分相同，这些节点构成的网络的叫子网
- 无需路由器介入（可以借助交换机），子网内各主机在物理上可以互相直接到达，即一跳可达

![image-20250307142202245](/../image-20250307142202245.png)

IP地址分类

- A类地址
  - 范围：1.0.0.0 到 126.0.0.0
  - 子网掩码：255.0.0.0 或 /8
  - 用途：适用于大型网络，如跨国公司或大型机构。
- B类地址
  - 范围：128.0.0.0 到 191.255.0.0
  - 子网掩码：255.255.0.0 或 /16
  - 用途：适用于中型网络，如大学或中型企业。
- C类地址
  - 范围：192.0.0.0 到 223.255.255.0
  - 子网掩码：255.255.255.0 或 /24
  - 用途：适用于小型网络，如小型企业或家庭网络。
- D类地址
  - 范围：224.0.0.0 到 239.255.255.255
  - 用途：用于多播通信，如视频会议和在线游戏。
- E类地址
  - 范围：240.0.0.0 到 255.255.255.255
  - 用途：保留用于实验和研究，不用于公共网络。

![image-20250307143633877](/../image-20250307143633877.png)

特殊地址

- 127.0.0.1：回环地址，用于本地测试。
- 内网专用地址：不会被当做公共地址来分配，在局域网中用于区分不同的设备，路由器**不对**目标地址是专用地址的分组进行转发
  - A类：10.0.0.0 到 10.255.255.255
  - B类：172.16.0.0 到 172.31.255.255
  - C类：192.168.0.0 到 192.168.255.255

子网掩码的特殊规定：

- 子网部分全0 => 本网络
- 主机部分全0 => 本主机
- 主机部分全1 => 广播地址，表示这个网络的所有主机

无类域间路由（Classless InterDomain Routing）

- 子网部分可以在任意位置
- 地址格式是a.b.c.d/x，x是地址中子网号的长度

![image-20250307144723543](/../image-20250307144723543.png)

路由表和路由算法：

- 路由器获得IP数据报中的目标地址
- 对于路由表中的每一个表项
  - 如果目标IP地址 & 子网掩码 == 表项中的目标子网，则按照对应接口转发数据报
  - 如果都没有找到，则使用默认表项转发数据报

![image-20250307145256310](/../image-20250307145256310.png)

主机如何获得IP地址

系统管理员将地址配置在文件中

通过**动态主机配置协议**（Dynamic Host Configuration Protocal）协议从服务器中动态获得一个IP地址

- 更新主机在用的IP地址的租用期
- 重新启动时，允许重新使用之前用过的IP地址
- 支持移动用户加入网络
- DHCP工作原理：
  - 主机广播DHCP discover报文（可选）
  - DHCP服务器用DHCP offer提供报文响应（可选）
  - 主机请求IP地址，发送DHCP request报文
  - DHCP服务器发送地址，发送DHCP ack报文

层次编址：通过将IP地址划分为多个层次结构，简化路由和管理。

1. 分层结构：IP地址分为网络部分和主机部分，网络部分可进一步划分子网。
2. 简化路由：路由器只需关注网络部分，减少路由表条目。

示例

- IP地址：192.168.1.1
- 子网掩码：255.255.255.0
- 网络地址：192.168.1.0
- 主机地址：1

路由聚集：通过将多个连续IP地址块合并为一个更大的地址块，减少路由表条目。

1. 减少条目：合并多个路由条目，降低路由表规模。
2. 提高效率：减少路由器处理时间和内存占用。

示例

- 多个网络：
  - 192.168.1.0/24
  - 192.168.2.0/24
  - 192.168.3.0/24
- 路由聚集：192.168.0.0/22

网络地址转换（Network Address Translation）：在 **私有网络** 和 **公共网络**之间转换 IP 地址，主要目的是解决 IPv4 地址不足的问题，并提高网络的安全性。

1. NAT 的作用

- IP 地址转换：将私有网络中的内部 IP 地址转换为公共 IP 地址，以便与外部网络通信。
- 节省公共 IP 地址：多个设备可以共享一个公共 IP 地址访问互联网。
- 增强安全性：隐藏内部网络的真实 IP 地址，防止外部直接访问内部设备。

IPv6：128bit的地址，固定40字节的报文头部

特点

- CheckSum被移除，减少路由器处理负担
- Options：在头部之外，被Next Header字段标示
- ICMPv6：ICMP报文的新版本，新增了“Packet Too Big”的报文类型，多播组管理功能

IPv4到IPv6过渡的方法：隧道（Tunneling），把IPv6分组封装在IPv4数据报中

![image-20250308183740652](/../image-20250308183740652.png)

### 通用转发和SDN

网络设备控制平面的实现方式特点：

- 通过分布式、每台设备的方法实现数据平面和控制平面的功能
  - 垂直集成：硬件和操作系统、互联网标准协议的私有实现
  - 每个设备都实现了数据平面和控制平面
  - 设备基本只能按照固定方式工作（控制逻辑固话），不同的网络功能需要不同的middle boxes（防火墙、负载均衡设备、NAT Boxes等）
- 数据和控制平面的集成
  - 升级代价大、管理困难

软件设计网络（Software Design Network）是逻辑上的控制平面

- 一个控制器和控制器代理（CA）交互，控制器决定分组的转发逻辑，CA所在设备执行逻辑

![image-20250308185012891](/../image-20250308185012891.png)

- 数据平面——分组交换机：按照流表进行PDU的动作，包括转发、丢弃、拷贝、泛洪、阻塞
- 控制平面——控制器+网络应用：计算、并通过**南向接口**下发控制逻辑（流表）给交换机
- 水平集成的控制平面创造良好的产业生态（分组交换机、控制器、网络应用可由不同厂商生产）
- 集中式实现控制逻辑使网络更容易管理

SDN控制器（网络操作系统）

- 维护网络状态信息
- 通过北向接口和网络控制应用交互
- 通过南向接口和网络交换机交互
- SDN控制器在逻辑上j集中，实现上由于性能、

![image-20250308190644649](/../image-20250308190644649.png)

- 通过match + action的方式，SDN可以实现各种网络设备提供的功能
  - 路由器：match 最长前缀匹配，action通过一条链路转发
  - 交换机：match 目标mac地址，action转发或泛洪
  - 防火墙：match IP地址和TCP/UDP端口号，action放行或禁止
  - NAT：match IP地址和端口号，action重写地址和端口号

![image-20250308191105543](/../image-20250308191105543.png)

## 数据链路层

### 路由选择算法

路由协议的目标：按照某种指标（传输延迟，经过的站点数目等），确定从源端到目标端之间的通过路由器的网络“较好”的路径，即路由器的序列，实际过程中按照**子网到子网**的路径计算为目标，而不是主机到主机。

- 正确性
- 简单性
- 健壮性：适应网络拓扑变化
- 稳定性
- 公平性
- 最优性

![image-20250309122321603](/../../AppData/Roaming/Typora/typora-user-images/image-20250309122321603.png)

最优化原则——汇集树（Sink Tree）：此节点到所有其他节点的最优路径形成的树，路由选择算法就是为所有路由器找到汇集树

路由选择算法分为：链路状态（Link State）算法和距离向量（Distance Vector）算法

- 链路状态算法是**全局式**的，所有路由器拥有完整的网络拓扑和边的代价信息
- 距离向量算法是**分布式**的，路由器只知道与它有物理连接的邻居路由器和到邻居路由器的代价，**迭代**地与邻居交换路由信息

链路状态（LS）算法（本质上是**迪杰斯特拉**算法）

- 发现邻居节点，获知网络地址、计算到邻居节点的代价
  - 发送一个分组要求对方立即响应
  - 测量时间估算出延迟情况
- 组装一个LS分组，描述自己到邻居节点地代价情况，包含
  - 发送者名称
  - 序号、年龄（为了避免无限泛洪）
  - 列表（它的邻居节点和到邻居节点的延迟）
- 将分组通过扩散（或泛洪）地方法发到其他所有路由器，这样每个路由器都获得网络拓扑和边代价
- 通过迪杰斯特拉算法找到最优路径

距离向量（DV）算法（本质上是**弗洛伊德**算法）

- 各路由器维护一张路由表
- 与相邻路由器交换路由表
- 根据获得的路由信息，更新路由表
- 每个路由器定期或某种事件（如本地链路变化、收到邻居发来的变化的路由表）触发将路由表传给邻居，并从邻居节点获得它们的距离矢量
- 距离矢量算法要经过多次迭代才能收敛到实际情况
- 问题：好消息传得快、坏消息传得慢（链路断了，可能会导致**路由环路**和**无穷计算**）

解决无穷计算的方法——**水平分裂**（Split Horizon）算法，又称**毒性逆转**算法，缓解坏消息传得慢的情况

链路状态算法和距离矢量算法对比 // TODO 做成表格

- 消息复杂度（DV胜出）：DV只和邻居交换信息；如果有n个节点，E条链路，LS要发送报文O(nE)个
- 收敛时间（LS胜出）：LS收敛较快但可能震荡；DV收敛较慢，可能存在路由环路和无穷计算问题
- 健壮性（LS胜出）：LS中若节点通知不正确的链路链路代价，每个节点只计算自己的路由表，错误信息影响范围小；DV节点若告知全网不正确的链路代价，每一个节点的路由表可能被其他节点使用，错误信息会扩散到全网。

### 自洽系统的内部网关协议

路由信息协议（Routing Information Protocol，RIP）：使用**距离矢量（DV）**算法

- 每条链路代价为1，最大跳数为15
- 每隔30秒邻居之间采用**UDP协议**交换通告信息，即距离向量
- 每个通告最多包含25个子网的可达性
- 若180秒内没有收到通告信息，判断邻居或链路失效，新的通告会传给邻居
- 使用水平分裂和设置最大跳数（为15）阻止回路

开放式最短路径优先（Open Shortest Path First，OSPF）协议：使用**链路状态（LS）**算法

- LS分组在一个自洽系统的网络中分发

- 全局网络拓扑和代价在每一个节点中都保持

- OSPF通告信息中携带每一个邻居路由器的表项，通过泛洪在自洽系统网络内部传播

- OSPF有一些RIP中没有的特性

  - 安全：所有的报文经过认证

  - 允许有多个代价相同的路径存在

  - 对于每一条链路，有多重代价矩阵

  - 对单播和多播的集成支持

  - 在大型网络中支持层次性OSPF

    ![image-20250309150552623](/../../AppData/Roaming/Typora/typora-user-images/image-20250309150552623.png)

### 边界网关协议

一个平面的路由：

- 一个网络中的所有路由器地位一样
- 通过链路状态算法、距离向量算法或其他算法，所有路由器都要知道其他所有路由器如何走
- 问题：如果网络规模巨大，路由信息的存储、传输和计算代价巨大；管理问题和安全问题

层次路由：将互联网分成一个个自洽系统（Autonomous System）

- 每个自洽系统用唯一的AS Number（ASN）表示
- 一个ISP可能包含一个或多个AS
- 使得路由变成了两个层次的路由
  - AS内部路由（Intra-AS）：在同一个AS内部，路由器运行相同的路由协议，如RIP、OSPF、IGRP等
  - AS间路由（Inter-AS）：使用边界网关协议解决AS之间的路由问题

层次路由的优点：

- 解决了规模问题：AS内部路由器的规模可控，如果节点增多可分割AS；每增加一个AS，对于AS间路由来说只是增加了一个节点
- 解决了管理和安全问题：各AS可以运行不同的内部网关协议，使得网络细节不向外透露
- 扩展性强：规模增大性能不会减少太多

边界网关协议（Border Gateway Protocol）

- eBGP（exterior BGP）：从相邻的AS网关那获得子网可达信息，并转发给相邻的AS网关，基于距离向量算法，但还包括到达各目标子网的详细路径（ASN列表），从而避免路由环路问题
- iBGP（interior BGP）：将获得的子网可达信息传遍AS内部的所有路由器

![image-20250309225608815](/../../AppData/Roaming/Typora/typora-user-images/image-20250309225608815.png)

- 如果到达一个子网有多条路径，路由器的路径选择可以基于：
  - 本地偏好属性
  - 最短AS路径
  - 最近的下一跳的路由（热土豆策略）

## 其他网络服务

### 差错检测和纠正

### 多点访问协议

### Lans

## 网络安全

